# Rubyの定数、もうひとつの意外な仕様

Rubyの定数が、他の言語の定数とはちょっと違う意外な仕様なのは理解していたが、もうひとつ意外な仕様があることを最近知った。なんかちょっと釣りっぽいタイトルになっちゃったけど。

<!-- READMORE -->


## 再代入可能な定数

Rubyの定数は、他の言語のように変更を許さない（再代入させない）定数ではないことは有名。少なくとも自分は、Rubyを始めてから結構早い段階でこの仕様について知った。そして、最初にこれを知ったとき「これって定数じゃなくね？」って思った覚えがある。

~~~ ruby
HOGE = "hoge"
HOGE = "fuga"
puts HOGE
~~~

このように再代入しても、警告は出るものの、実際の値は変わってしまう。

~~~ sh
2: warning: already initialized constant HOGE
fuga
~~~

Rubyのこういった仕様に対して、良い意味での“ゆるふわ感”を感じる。こんなにゆるくて大丈夫？と思うくらい。


> 言語の硬度を測定すると、Javaは硬度8くらい、Pythonは6くらいになるのに対して、Rubyは3くらいになる。柔らかい手触りが好きだなと思う人はRubyを学ぶといいかも。
最近話題になっている人気プログラミング言語解説のRubyの項目で触れられている、この硬度の話もこういうことも含まれるんじゃないかなぁと思っている。
>
> <cite>[プログラミング言語人気TOP10の簡易解説](http://www.mwsoft.jp/column/program_top10.html)</cite>


## もうひとつの意外な仕様

意外な仕様、なんて大層なことじゃないかもだけど、今日やってみるまで知らなかった。これは逆にRubyっぽい“ゆるふわ”な感じはしない。なぜこういう仕様なのかわからない。

さて、このコードを実行したら何と出力されるでしょう？

~~~ ruby
def hoge
  FUGA = "fuga"
end
puts hoge  #=> 出力結果はなんでしょう？
~~~

結果は…

~~~ sh
2: dynamic constant assignment
  FUGA = "fuga"
        ^
~~~

なんとエラー！ もしかして常識？ Rubyの定数の仕様として、*メソッド内では定数の定義ができない。*これは意外だった。

> 定数の定義 (と初期化) は代入によって行われますが、メソッドの中では定義できません。
>
> <cite>[変数と定数](http://rurema.clear-code.com/1.8.7/doc/spec=2fvariables.html#const)</cite>


なぜこういう仕様になっているのかはわからない。けど、クラスの仕様と関連してそう。上記のエラー文でググると、同じようにハマっている人がそこそこいるのがわかる。

自分の狭いプログラミング言語経験では、こういう仕様の言語を他に見たことが無い気がする。試しに普段良く使う[AS3でメソッド内に定数を定義](http://wonderfl.net/c/2niH)してみたらできた。まぁ普通そうだよね。できるよね。

* * *

<cite>[変数と定数](http://rurema.clear-code.com/1.8.7/doc/spec=2fvariables.html#const)</cite>
